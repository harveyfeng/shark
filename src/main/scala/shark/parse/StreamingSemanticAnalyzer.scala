package shark.parse

import scala.collection.JavaConversions._
import scala.collection.mutable.{ArrayBuffer, ListBuffer}

import java.lang.reflect.Method
import java.util.{ArrayList, List => JavaList, Map => JavaMap}

import org.apache.hadoop.fs.Path
import org.apache.hadoop.hive.conf.HiveConf
import org.apache.hadoop.hive.metastore.api.{FieldSchema, MetaException}
import org.apache.hadoop.hive.metastore.Warehouse
import org.apache.hadoop.hive.ql.exec.{DDLTask, FetchTask, MoveTask, Task, TaskFactory}
import org.apache.hadoop.hive.ql.metadata.HiveException
import org.apache.hadoop.hive.ql.optimizer.Optimizer
import org.apache.hadoop.hive.ql.parse._
import org.apache.hadoop.hive.ql.plan._
import org.apache.hadoop.hive.ql.session.SessionState

import shark.execution.{HiveOperator, CQWork, CQTask, Operator, SparkTask, StreamScanOperator, StreamingLaunchWork,
  TableScanOperator, TerminalOperator}
import shark.execution.{CQWork, TableRDD}
import shark.SharkEnv

import spark.streaming.{DStream, Duration, StreamingContext}
import spark.RDD


class StreamingSemanticAnalyzer(conf: HiveConf) extends SharkSemanticAnalyzer(conf) {

  override def analyzeInternal(ast: ASTNode): Unit = {
    reset()

    val qb = new QB(null, null, false)
    var pctx = getParseContext()
    pctx.setQB(qb)
    pctx.setParseTree(ast)
    init(pctx)
    var child: ASTNode = ast

    val cmdContext = pctx.getContext().asInstanceOf[StreamingCommandContext]
    var isCTAS = false
    var td = qb.getTableDesc

    var shouldReset = false

    logInfo("Starting Shark Streaming Semantic Analysis")

    // if (ast.getToken().getType() == SharkParser.TOK_CREATESTREAM) isCreateStream = true
    // Analyze CREATE TABLE command
    if (ast.getToken().getType() == HiveParser.TOK_CREATETABLE) {
      // Note: this means streams are tables...
      // super.analyzeInternal(ast)
      for (ch <- ast.getChildren.asInstanceOf[JavaList[ASTNode]]) {
        ch.getToken.getType match {
          case HiveParser.TOK_QUERY => {
            // Fill cmdContext with metadata info, such as stream <-> window mapping.
            StreamASTTraversal.processQueryNode(ch, cmdContext)
            isCTAS = true
            child = ch.asInstanceOf[ASTNode]
          }
          case _ =>
            Unit
        }
      }

      // TODO: temporary
      // if streaming, get data needed to create DStreams
      if (cmdContext.isCreateStream) {
        if (isCTAS) {
          // CSAS.
          // Get the query plan from SharkSemanticAnalyzer.
          // This is a DStream transform, so use TableRDDSinkOperator
          this.ctx = new QueryContext(conf, true)
          super.analyzeInternal(ast)
          shouldReset = true
        } else {
          // TODO: Use a StreamDesc, parent CreateTableDesc?
          super.analyzeInternal(ast)
          // If the table descriptor can be null if the CTAS has an
          // "if not exists" condition.
          val td = getParseContext.getQB.getTableDesc
          analyzeCreateStream(td)
          return
        }
      } else {
        // Regular CREATE TABLE/CTAS
        super.analyzeInternal(ast)
        return
      }
    } else {
      // This is a query. Still need to check for table sources that are streams.
      SessionState.get().setCommandType(HiveOperation.QUERY)
      super.analyzeInternal(ast)
    }

    // Determine if there is a stream source.
    if (cmdContext.streamToWindow.size == 0) {
      if (cmdContext.isCreateStream && isCTAS) {
        throw new SemanticException(
          "Must include at least one stream source for creating a derived stream")
      } else {
        return
      }
    }

    // At this point, the command is either a CSAS, a real-time query that involves
    // stream(s), or an "archive" command.

    // Get the tasks generated by SharkSemanticAnalyzer.
    // There's one SparkTask created for each TerminalOperator.
    val sparkTasks = rootTasks.asInstanceOf[JavaList[SparkTask]]
    rootTasks.clear()

    // Find all stream source TableScanOperators, and convert them to StreamScanOperators.
    // TODO: The populate operator metadata related to streams is added here, but maybe
    // should be done during Task initialization.
    if (sparkTasks.size == 1) {
      // If the any TableScanOperator is for a DStream input source,
      // replace it with StreamScanOperator.
      val terminalOp = sparkTasks.head.getWork.terminalOperator
      val pctx = getParseContext
      val topToTable = pctx.getTopToTable
      val inputStreams = new ArrayBuffer[DStream[_]]()

      for (topOp <- terminalOp.returnTopOperators) {
        val tableName = topToTable.get(topOp.hiveOp).getTableName
        SharkEnv.streams.getStream(tableName) match {
          case stream: DStream[_] => {
            val streamScanOp = StreamingSemanticAnalyzer.convertTableScanToStreamScan(
              topOp.asInstanceOf[TableScanOperator])

            // Do some StreamScanOp initialization...move to CQTask?
            streamScanOp.tableName = tableName
            streamScanOp.windowDuration = cmdContext.streamToWindow.get(tableName)

            // TODO: should we set source stream for each StreamScanOp here?
            //       Depends on whether streams are immutable...
            inputStreams.append(stream)
            cmdContext.streamOps.append(streamScanOp)
          }
          case _ => Unit
        }
      }

      if (cmdContext.isCreateStream && isCTAS) {
        // If CSAS, add the transformedDStream to metadata
        cmdContext.tableName = td.getTableName

        // TODO: pass this through cmdContext at parsing stage.
        val tblProps = td.getTblProps
        // Seconds
        val duration = Duration(tblProps.get("batch").toLong * 1000)
        cmdContext.isDerivedStream = true

      } else if (pctx.getQB.getParseInfo.isInsertToTable && !qb.isCTAS) {
        cmdContext.isArchiveStream = true
      }

      genStreamingTasks(cmdContext, inputStreams, sparkTasks.head)

    } else {
      // Don't support mutiple SparkTasks created from condensed DDLs (ex. multi-insert).
      throw new SemanticException(
        "Can't do multiple SparkTask plan generation in streaming mode yet")
    }
    logInfo("Completed streaming plan generation")
  }

  // Create input stream for given table.
  def analyzeCreateStream(td: CreateTableDesc) {
    val tblProps = td.getTblProps()
    val batchDuration = tblProps.getOrElse("batch-duration", "1").toLong
    val readDirectory = tblProps.get("read-directory")

    // Stream name
    val tableName = td.getTableName
    // Use seconds for now
    val duration = Duration(batchDuration * 1000)
    // This creates the FileInputStream, and handles metadata additions.
    SharkEnv.streams.createTextFileStream(tableName, readDirectory, duration)
  }

  def genStreamingTasks(
    cmdContext: StreamingCommandContext,
    sourceDStreams: Seq[DStream[_]],
    sparkTask: SparkTask
  ) {
    val executor = getExecutor(sourceDStreams, cmdContext.duration)
    // Create the CQTask
    val cqTask = TaskFactory.get(new CQWork(cmdContext, sparkTask, executor), conf)

    if (cmdContext.isDerivedStream) {
      // Tasks created by Shark:
      // SparkTask -> {MoveTask, DDLTask}
      // Discard the MoveTask. Replace SparkTask with CQTask.
      // New plan: CQTask -> DDLTask
      cqTask.addDependentTask(sparkTask.getChildTasks.get(1))
      for (child <- sparkTask.getChildTasks) {
        sparkTask.removeDependentTask(child)
      }
    } else if (cmdContext.isArchiveStream) {
      // If the StreamingContext used for this executor DStream hasn't been started, add a
      // StreamingLaunchTask as a dependency to the CQTask, which adds an output DStream (foreach).
      if (!SharkEnv.streams.hasSscStarted(executor)) {
        val launchTask = TaskFactory.get(
            new StreamingLaunchWork(SharkEnv.streams.getSsc(executor)), conf)
        rootTasks.add(launchTask)
        cqTask.addDependentTask(launchTask)
      }
    }

    rootTasks.add(cqTask)
  }

  def getExecutor(sourceDStreams: Seq[DStream[_]], duration: Duration): DStream[_] = {
    // Use the DStream with smallest slideDuration.
    val sourceDStream = sourceDStreams.sortWith(_.slideDuration < _.slideDuration).head
    // If the user provides a batch duration and there are > 1 sources, trust that
    // it will be a valid duration (for now)
    if (duration == null) {
      return sourceDStream
    } else {
      sourceDStream.window(duration, duration)
    }
  }
}

object StreamingSemanticAnalyzer {

  // TODO: these should be in a StreamingOperatorFactory
  def convertTableScanToStreamScan(tableScanOp: TableScanOperator): StreamScanOperator = {
    val newOp = _newStreamingOperatorInstance(classOf[StreamScanOperator], tableScanOp)
      _replaceOpInTree(tableScanOp, newOp)
    return newOp.asInstanceOf[StreamScanOperator]
  }

  private def _replaceOpInTree(originalOp: Operator[_], newOp: Operator[_]) {
    originalOp.childOperators.foreach { childOp =>
      childOp.parentOperators.remove(originalOp)
      childOp.addParent(newOp)
    }
    originalOp.parentOperators.foreach { parentOp =>
      parentOp.childOperators.remove(originalOp)
      parentOp.addChild(newOp)
    }
  }

  private def _newStreamingOperatorInstance[T <: HiveOperator](
    cls: Class[_ <: Operator[T]], sharkOp: Operator[T]): Operator[_] = {
    val newOp = cls.newInstance()
    newOp.hiveOp = sharkOp.hiveOp.asInstanceOf[T]
    return newOp
  }
}
